<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Torsten Stöter">
<meta name="dcterms.date" content="2025-03-21">

<title>Scale-invariant projections for data visualization – Farpoint Folio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d4be639c637f3db3c684c66cefad7e0c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Farpoint Folio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tstoeter"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Scale-invariant projections for data visualization</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Papers</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Torsten Stöter </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 21, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In this post I review and summarize the general concepts and contributions of the Euro Graphics 2025 paper "Towards Scaling-Invariant Projections for Data Visualization" by <span class="citation" data-cites="dierkes2025">Dierkes et al. (<a href="#ref-dierkes2025" role="doc-biblioref">2025</a>)</span>.</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In their 2025 EG visualization paper, Dierkes at al.&nbsp;aim for visually optimal 2-d scatter plots of high-dimensional data. To this end, the authors utilize dimensionality reduction techniques, such as PCA, t-SNE, and MDS for projecting the high-dimensional data into 2-d space. The outcome of this projection depends on how the data is scaled in original high-dimensional space and may lead to unsatisfactory outcomes. Thus, in parallel to dimensionality reduction, this projection is also optimized for the best data scaling w.r.t. selected quality measures in order to maximize the visual quality of the projection. This method becomes a scale invariant projection, since the used optimization is deterministic and yields the same scaling for the same data. The paper is a clearly and very well written, and well motivated, yet a few open problems remain.</p>
</section>
<section id="motivating-examples" class="level1">
<h1>Motivating examples</h1>
<p>Three motivating examples show that visual presentation, perception, and interpretation of scatter plots is subject to the chosen data scaling. Also PCA depends on scaling as demonstrated for both 2-d data and higher-dimensional data (4-d).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="clusters.webp" class="img-fluid figure-img"></p>
<figcaption>This example shows, how clusters in data are perceived depending on data scaling. There are either three clusters (top left) or two different versions with two clusters (bottom and right).</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="scaled-pca.webp" class="img-fluid figure-img"></p>
<figcaption>This example shows how PCA is affected by data scaling, here horizontal scaling by 2. However, the same scaling applied to the original PCA eigenvectors (left) yields different results (middle, right).</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="clusters-penguins.webp" class="img-fluid figure-img"></p>
<figcaption>The projection using PCA of differently scaled versions of the Palmer penguins 4-d dataset shows how visual class separation is affected.</figcaption>
</figure>
</div>
<p>The data scaling in high-dimensional space depends on e.g.&nbsp;the chosen units or data types. This can be varied and data scaling is assumed to be arbitrary. Hence, which is the optimal data scaling produces the visually best 2-d scatter plot?</p>
</section>
<section id="problem-formulation" class="level1">
<h1>Problem formulation</h1>
<p>Let <span class="math inline">\(\mathbf{X} \in \mathbb{R}^{n \times p}\)</span> be a data matrix with p many n-dimensional data points. The scaling matrix <span class="math inline">\(\mathbf{K} := diag(k)\)</span> with <span class="math inline">\(\mathbf{k} := (k_1,...,k_n)\)</span> and <span class="math inline">\(k_i \neq 0\)</span> defines a non-uniform scaling, which applied to the data matrix <span class="math inline">\(\mathbf{X}\)</span> yields the scaled data matrix <span class="math inline">\(\mathbf{X}' = \mathbf{K}\mathbf{X}\)</span>. Let <span class="math inline">\(\pi: \mathbb{R}^n \to \mathbb{R}^2\)</span> be some projection from n-dimensional data space into 2-dimensional space. The projection <span class="math inline">\(\pi\)</span> becomes scale invariant, if before projection, the data <span class="math inline">\(\mathbf{X}\)</span> is transformed to a common reference scale (independent of its initial scaling) using an optimal rescaling function <span class="math inline">\(\mathbf{K^*}\)</span>, i.e.&nbsp;<span class="math display">\[
\mathbf{K^*} (\mathbf{X'}) \mathbf{X'} = \mathbf{K^*} (\mathbf{X}) \mathbf{X}
\]</span> for any data <span class="math inline">\(\mathbf{X}\)</span> and any scaling <span class="math inline">\(\mathbf{K}\)</span>.</p>
<p>Remarks:</p>
<ul>
<li>Normalization and standardization are two common examples for such rescalings.</li>
<li>The application of rescaling, <span class="math inline">\(\mathbf{K}_a(X) := \mathbf{K^*}(\mathbf{X})\mathbf{X}\)</span>, is itself a projection, since <span class="math inline">\(\mathbf{K}_a \circ \mathbf{K}_a =  \mathbf{K}_a\)</span>.</li>
</ul>
<p>The goal is to achieve a visually optimal projection. Given a quality measure <span class="math inline">\(q\)</span> to assess the visual quality, the component vector <span class="math inline">\(\mathbf{k^*}\)</span> for the optimal rescaling function <span class="math inline">\(\mathbf{K^*}\)</span> can be found by maximizing the visual quality <span class="math inline">\(q\)</span>, i.e.&nbsp;<span class="math display">\[
\mathbf{k^*} := \underset{\mathbf{k}}{arg\, max} \ q( \pi ( diag ( \mathbf{k} ) \mathbf{X} ) ).
\]</span> Which visual quality measures are chosen and how they look like, follows in the next section.</p>
</section>
<section id="quality-measures" class="level1">
<h1>Quality measures</h1>
<p>The visual quality measures DSC, CDM, DC and DSR were used, which operate on labeled data, i.e.&nbsp;all data points require a class label. The first three were introduced in <span class="citation" data-cites="tatu2009">Tatu et al. (<a href="#ref-tatu2009" role="doc-biblioref">2009</a>)</span> and <span class="citation" data-cites="sips2009">Sips et al. (<a href="#ref-sips2009" role="doc-biblioref">2009</a>)</span>, and showed high ranking performance among other measures reviewed in <span class="citation" data-cites="sedlmair2015">Sedlmair and Aupetit (<a href="#ref-sedlmair2015" role="doc-biblioref">2015</a>)</span>. For reason of brevity, I omit the DC measures’ definition here.</p>
<p>The quality measures assess the visual quality of the projected scatter plots. There are p many 2-d projected points <span class="math inline">\(\mathbf{x_1},...,\mathbf{x_p} \in \mathbb{R}^2\)</span> with <span class="math inline">\(m\)</span> associated distinct class labels.</p>
<section id="data-consistency-dsc" class="level2">
<h2 class="anchored" data-anchor-id="data-consistency-dsc">Data Consistency (DSC)</h2>
<p>The data consistency measure penalizes points that are closer to another class centroid than their own class' centroid. <span class="math display">\[
DSC := \frac{1}{p} \sum CD(\mathbf{x_i}, class(\mathbf{x_i})),
\]</span> with centroid distance penalty function applying some distance metric <span class="math inline">\(d\)</span> <span class="math display">\[
CD(\mathbf{x}, c_j) := \begin{cases}
0, &amp; \text{if}\ d(\mathbf{x},centr(c_j) &lt; d(\mathbf{x},centr(c_k)) \ \forall k \in [m], k \neq j \\
1, &amp; \text{otherwise}
\end{cases}
\]</span> where <span class="math inline">\(centr(c)\)</span> gives the centroid of a class label <span class="math inline">\(c\)</span>.</p>
</section>
<section id="class-density-measure-cdm" class="level2">
<h2 class="anchored" data-anchor-id="class-density-measure-cdm">Class Density Measure (CDM)</h2>
<p>The class density measures computes the total distance between all point pairs of different classes <span class="math display">\[
CDM := \sum_{\substack{i \in C_k\\ k \in [m]}} \sum_{\substack{j \in C_l\\ l \in [m]\setminus [k] }} || \mathbf{x_i} - \mathbf{x_j} ||
\]</span> where <span class="math inline">\(C_k\)</span> is the set of all indices of points belonging to class <span class="math inline">\(k\)</span>.</p>
</section>
<section id="data-space-ratio-dsr" class="level2">
<h2 class="anchored" data-anchor-id="data-space-ratio-dsr">Data Space Ratio (DSR)</h2>
<p>The data space ratio is inspired by Tufte's data/ink ratio for data visualization. For this, the projected points are binned into a grid of bin size <span class="math inline">\((w,h) \in \mathbb{R}_{&gt;0}^2\)</span> that covers the domain with equal amount of bins per dimension. The DSR is given by <span class="math display">\[
DSR := \frac{100}{n} \sum_j sgn(p_j)
\]</span> where <span class="math inline">\(p_j\)</span> counts the points in the bin j.</p>
</section>
</section>
<section id="implementation" class="level1">
<h1>Implementation</h1>
<p>The derivative-free Nelder-Mead algorithm is employed for optimization, because not all quality measures above are differentiable, DSC and DSR are not even continuous. Non-linear optimization is generally sensitive to the initial starting point. Using z-score standardization a unique canonical starting point is obtained. This ensures the optimization and rescaling remain deterministic, and maintains scale-invarience of the Nelder-Mead optimization steps. For DSR 100x100 bins have been chosen equidistantly per dimension, and for DC 100 equally sized bins have been chosen.</p>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>The proposed method produces unique deterministic scaling invariant projections with generally improved scatter plot visualization, better perception and easier interpretation in the shown examples. Here, I show only results for two out of the four example datasets used in the paper.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="results-penguins.webp" class="img-fluid figure-img"></p>
<figcaption>Scatter plots of the Palmer penguins dataset under three different projections after common (unscaled, z-score) and optimized rescaling (DSC,CDM,DC,DSR) of the data. The visually optimal rescalings generally show better class separation than the common approaches.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="results-covertype.webp" class="img-fluid figure-img"></p>
<figcaption>Scatter plots of the high-dimensional Covertype dataset under three different projections after common (unscaled, z-score) and optimized rescaling (DSC,CDM,DC,DSR) of the data. The optimized projections do not show better, but also no worse visualizations than the common rescalings. Scatter plots for very high-dimensional data are inherently difficult.</figcaption>
</figure>
</div>
<p>For very large datasets with many dimensions and many classes, performance was reported to be an issue. Hence, quality measures and the optimal rescaling for the Covertype dataset were computed only on a random subset of the data.</p>
</section>
<section id="limitations-and-open-problems" class="level1">
<h1>Limitations and open problems</h1>
<p>The authors openly discuss limitations of their approach. Very high-dimensional dataset remain difficult to visualize, as seen for the Covertype dataset. Also the reported performance is highly dependent on dataset size, rendering the scale optimization for a complete and very large datasets unfeasible.</p>
<p>Except for DSR, the other quality measures require labeled data, and only labeled datasets were considered. What results would this approach achieve using other label-free quality measures?</p>
<p>For the Bankruptcy dataset its nominal data is encoded as integers, but this ordering is arbitrary. Any order of categories is as good as the other, but may affect the scaling. Also categories/integer cannot be used for computations (PCA, optimization, scaling).</p>
<p>How consistent are the projections, when new data is added or data is removed? Suddenly, the projections could look very different. This may also effect the random sub-sampling of the Covertype dataset. Analyzing how much the quality measures change when the underlying dataset size changes could give a first indication.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-dierkes2025" class="csl-entry" role="listitem">
Dierkes, J., D. Stelter, C. Rössl, and H. Theisel. 2025. <span>“Towards Scaling-Invariant Projections for Data Visualization.”</span> <em>Computer Graphics Forum (Proc. Eurographics)</em> 44 (2).
</div>
<div id="ref-sedlmair2015" class="csl-entry" role="listitem">
Sedlmair, M., and M. Aupetit. 2015. <span>“Data-Driven Evaluation of Visual Quality Measures.”</span> <em>Computer Graphics Forum</em> 34 (3): 201–10. <a href="https://doi.org/10.1111/cgf.12632">https://doi.org/10.1111/cgf.12632</a>.
</div>
<div id="ref-sips2009" class="csl-entry" role="listitem">
Sips, Mike, Boris Neubert, John P. Lewis, and Pat Hanrahan. 2009. <span>“Selecting Good Views of High-Dimensional Data Using Class Consistency.”</span> <em>Computer Graphics Forum</em> 28 (3): 831–38. <a href="https://doi.org/10.1111/j.1467-8659.2009.01467.x">https://doi.org/10.1111/j.1467-8659.2009.01467.x</a>.
</div>
<div id="ref-tatu2009" class="csl-entry" role="listitem">
Tatu, Andrada, Georgia Albuquerque, Martin Eisemann, Jorn Schneidewind, Holger Theisel, Marcus Magnork, and Daniel Keim. 2009. <span>“Combining Automated Analysis and Visualization Techniques for Effective Exploration of High-Dimensional Data.”</span> In <em>2009 IEEE Symposium on Visual Analytics Science and Technology</em>, 59–66. <a href="https://doi.org/10.1109/VAST.2009.5332628">https://doi.org/10.1109/VAST.2009.5332628</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>